package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import kotlin.math.roundToInt
import kotlin.math.sqrt

@ModuleInfo(name = "Disabler", description = "Disable anticheats", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {
    private val modeValue= ListValue("Mode",arrayOf("MinePlexCombat","OldHypixel","VerusCombat","VerusCombat2","VerusMove"),"MinePlexCombat")
    private val debug = BoolValue("Debug", true)

    private var verus2Stat=false
    private var transPackets=mutableListOf<C0FPacketConfirmTransaction>()
    private var currentTrans=0

    override fun onEnable() {
        reset()
    }

    @EventTarget
    fun onWorld(event: WorldEvent){
        reset()
    }

    private fun reset(){
        currentTrans=0
        verus2Stat=false
        transPackets.clear()
    }

    @EventTarget
    fun onPacket(event: PacketEvent){
        val packet=event.packet

        when(modeValue.get().toLowerCase()){
            "mineplexcombat" -> {
                if (packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                    ClientUtils.sendPacketNoEvent(C00PacketKeepAlive(packet.key-RandomUtils.nextInt(1000, 2147483647)))
                    if (debug.get()) ClientUtils.displayAlert(" [Disabler] Packet C00")
                }
            }

            "oldhypixel" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if (packet.uid < 0 && packet.windowId == 0) {
                        event.cancelEvent()
                        if (debug.get()) ClientUtils.displayAlert(" [Disabler] Packet C0F")
                    }
                }
            }

            "veruscombat" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if(currentTrans > 0) event.cancelEvent()
                    currentTrans++
                    if (debug.get()) ClientUtils.displayAlert(" [Disabler] Packet C0F (Trans=$currentTrans)")
                } else if(packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                    if (debug.get()) ClientUtils.displayAlert(" [Disabler] Packet C0B")
                }
            }

            "veruscombat2" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if (!verus2Stat) {
                        transPackets.add(packet)
                        if (debug.get()) ClientUtils.displayAlert(" [Disabler] Add Packet")
                        event.cancelEvent()
                    } else {
                        verus2Stat = false
                    }
                }else if (packet is C00PacketKeepAlive) {
                    ClientUtils.sendPacketNoEvent(C00PacketKeepAlive(RandomUtils.nextInt(1, 2147483647)))
                    if (debug.get()) ClientUtils.displayAlert(" [Disabler] Keep Alive")
                    event.cancelEvent()
                }else if (packet is C03PacketPlayer) {
                    ClientUtils.sendPacketNoEvent(C0CPacketInput())
                    if (mc.thePlayer.ticksExisted % 15 == 0) {
                        packet.y += RandomUtils.nextInt(100, 1000)
                        if (debug.get()) ClientUtils.displayAlert(" [Disabler] Packet C03")
                    }
                }
            }

            "verusmove" -> {
                if (mc.thePlayer != null && mc.thePlayer.ticksExisted == 0) transPackets.clear()
                if (packet is C03PacketPlayer) {
                    // Set position to a valid block height (so Spoof NoFall works)
                    val yPos = (mc.thePlayer.posY / 0.015625).roundToInt() * 0.015625
                    mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)
                    if (mc.thePlayer.ticksExisted % 45 == 0) {
                        // Clip into ground and silently accept the teleport from the server. (This fucks with teleport compensation LOL)
                        ClientUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                        ClientUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 11.725, mc.thePlayer.posZ, false))
                        ClientUtils.sendPacketNoEvent(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                    }
                } else if (packet is S08PacketPlayerPosLook) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    // Cancel the teleport, and silently accept it.
                    if (diff <= 8) {
                        event.cancelEvent()
                        // LATEST verus ALWAYS expects a c06 within 30 seconds of a teleport if packets have been sent from the client after the teleport.
                        ClientUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
                    }
                } else if (packet is C0FPacketConfirmTransaction) {
                    for (i in 0..3) {
                        // Make sure to dupe packets 4 times, since it will match up with the missing packets while keeping the anticheat disabled, in order to bypass ping spoof checks
                        // why the fuck do they not checked duped transactions? LMFAO
                        transPackets.add(packet)
                    }
                    event.cancelEvent()
                }
            }
        }
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent){
        when(modeValue.get().toLowerCase()){
            "veruscombat2" -> {
                mc.timer.timerSpeed = 0.6F
                if (mc.thePlayer.ticksExisted % 50 == 0 && (transPackets.size - 1) > currentTrans) {
                    verus2Stat = true
                    ClientUtils.sendPacketNoEvent(transPackets[++currentTrans])
                    if (debug.get()) ClientUtils.displayAlert(" [Disabler] Send Trans")
                }
                if (mc.thePlayer.ticksExisted % 500 == 0) {
                    transPackets.clear()
                    if (debug.get()) ClientUtils.displayAlert(" [Disabler] Clear Trans")
                    currentTrans = 0
                }
            }

            "verusmove" -> {
                // Partially drain the queue every 180 ticks (9 seconds), to prevent flagging Ping Spoof.
                if (mc.thePlayer.ticksExisted % 180 == 0) {
                    // grab packets untill the queue size is 22 or less.
                    while (transPackets.size > 22) {
                        // grab 1 packet, send and then remove it from the queue
                        ClientUtils.sendPacketNoEvent(transPackets[0])
                        transPackets.removeAt(0)
                    }
                }
            }
        }
    }

    override val tag: String
        get() = modeValue.get()
}
